mod runepool_history;
use chrono::{NaiveDate, Utc};
pub use runepool_history::RunepoolHistory;
use reqwest::get;
use serde_json::Value;
use shared::{create_db_pool, run_migrations};
use sqlx::Error;


#[tokio::main]
async fn main() {
    let pool = create_db_pool().await.unwrap();
    let pool = pool.lock().await;
    run_migrations(&pool).await.unwrap();
    let res = fetch_and_insert_data(&pool).await;
    if let Err(e) = res {
        eprintln!("Error: {:?}", e);
    }
}

async fn fetch_and_insert_data(pool: &sqlx::PgPool) -> Result<(), Error> {
    let start_date = NaiveDate::from_ymd_opt(2024, 10, 1)
        .unwrap_or_else(|| panic!("Invalid date"))
        .and_hms_opt(0, 0, 0)
        .unwrap();

    let mut from_time = start_date.timestamp();

    // Retrieve the last successful entry's endTime from the FetchState table, defaulting to 1 Oct 2024 if not found
    let last_successful_entry = get_last_successful_entry(&pool).await.unwrap_or_else(|_| {
        println!("{:?}", start_date.timestamp());
        start_date.timestamp() // Make sure to convert to DateTime<Utc>
    });
    from_time = last_successful_entry;

    // Set end time as the current time
    let end_time = Utc::now().timestamp();
    let mut count = 0;

    // Loop to fetch data in chunks of 400
    loop {
        // Construct the API request URL with `from_time` and `count=100`
        let url = format!(
            "https://midgard.ninerealms.com/v2/history/runepool?interval=hour&from={}&count=100",
            from_time
        );
        println!("{:?}", url);

        // Make the API request
        let response: Value = get(&url).await.unwrap().json().await.unwrap();

        if let Some(intervals) = response["intervals"].as_array() {
            // Loop through the data and insert each entry into the database
            for entry in intervals {
                // Create RunepoolHistory struct from the API response
                let runepool_history = RunepoolHistory {
                    id: None, // This will be auto-generated by PostgreSQL
                    startTime: entry["startTime"].as_str().unwrap().parse::<i64>().unwrap(),
                    endTime: entry["endTime"].as_str().unwrap().parse::<i64>().unwrap(),
                    units: entry["units"].as_str().unwrap().parse::<i64>().unwrap(),
                    count: entry["count"].as_str().unwrap().parse::<i32>().unwrap(),
                };
                // println!("{:?}", runepool_history);
                // Insert the data into the database using RunepoolHistory struct
                match sqlx::query!(
                    r#"
                    INSERT INTO runepool_history (startTime, endTime, units, count)
                    VALUES ($1, $2, $3, $4)
                    "#,
                    runepool_history.startTime,
                    runepool_history.endTime,
                    runepool_history.units,
                    runepool_history.count
                )
                .execute(pool)
                .await
                {
                    Ok(_) => {}
                    Err(e) => {
                        if let sqlx::Error::Database(db_err) = &e {
                            if db_err.code() == Some("23505".into()) {
                                // Skip this entry due to duplicate key error
                                continue;
                            }
                        }
                        return Err(e);
                    }
                };

            }

            let last_entry = intervals.last().unwrap();
            let last_end_time = last_entry["endTime"]
                .as_str()
                .unwrap()
                .parse::<i64>()
                .unwrap();

            // If the `end_time` of the last entry is greater than or equal to current time, we are done
            if last_end_time >= end_time {
                break;
            }

            // Otherwise, update `from_time` to the `end_time` of the last entry
            from_time = last_end_time;
        } else {
            break; // No more data, exit loop
        }
    }
    Ok(())
}

// Fetch the last successful entry's `endTime` from the FetchState table
async fn get_last_successful_entry(pool: &sqlx::PgPool) -> Result<i64, Error> {
    let result = sqlx::query!(
        r#"
        SELECT last_successful_entry FROM fetch_state WHERE table_name = 'runepool_history'
        "#,
    )
    .fetch_optional(pool)
    .await?;
    let default_value = NaiveDate::from_ymd_opt(2024, 10, 1)
        .unwrap_or_else(|| panic!("Invalid date"))
        .and_hms_opt(0, 0, 0)
        .unwrap()
        .timestamp();
    let res = result
        .map(|r| r.last_successful_entry)
        .unwrap_or(default_value.into());
    if res == 0 {
        return Ok(default_value.into());
    }
    Ok(res)
}
