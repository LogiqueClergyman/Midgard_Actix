mod model;
use chrono::{NaiveDate, TimeZone, Utc};
pub use model::AssetPriceHistory;
use reqwest::get;
use serde_json::Value;
use shared::{create_db_pool, run_migrations};
use sqlx::Error;
#[tokio::main]
async fn main() {
    let pool = create_db_pool().await.unwrap();
    let pool = pool.lock().await;

    let res = fetch_and_insert_data(&pool).await;
    if let Err(e) = res {
        eprintln!("Error: {:?}", e);
    }
    run_migrations(&pool).await.unwrap();
}
async fn fetch_and_insert_data(pool: &sqlx::PgPool) -> Result<(), Error> {
    let start_date = NaiveDate::from_ymd_opt(2024, 11, 29)
            .unwrap_or_else(|| panic!("Invalid date"))
            .and_hms_opt(0, 0, 0)
            .unwrap();
    let mut from_time = Utc.from_utc_datetime(&start_date).timestamp();

    // Set end time as the current time
    let end_time = Utc::now().timestamp();
    let mut count = 0;
    // Loop to fetch data in chunks of 400
    loop {
        // Construct the API request URL with `from_time` and `count=400`
        let url = format!(
            "https://midgard.ninerealms.com/v2/history/depths/BTC.BTC?interval=hour&from={}&count=100", 
            from_time
        );
        // println!("{:?}", url);
        // Make the API request
        let response: Value = get(&url).await.unwrap().json().await.unwrap();
        // println!("{:?}", response);
        if let Some(intervals) = response["intervals"].as_array() {
            // Loop through the data and insert each entry into the database
            for entry in intervals {
                let assetPriceHistory = AssetPriceHistory {
                    assetDepth: entry["assetDepth"]
                        .as_str()
                        .unwrap()
                        .parse::<i64>()
                        .unwrap(),
                    assetPrice: entry["assetPrice"]
                        .as_str()
                        .unwrap()
                        .parse::<f64>()
                        .unwrap(),
                    assetPriceUSD: entry["assetPriceUSD"]
                        .as_str()
                        .unwrap()
                        .parse::<f64>()
                        .unwrap(),
                    liquidityUnits: entry["liquidityUnits"]
                        .as_str()
                        .unwrap()
                        .parse::<i64>()
                        .unwrap(),
                    luvi: entry["luvi"].as_str().unwrap().parse::<f64>().unwrap(),
                    membersCount: entry["membersCount"]
                        .as_str()
                        .unwrap()
                        .parse::<i32>()
                        .unwrap(),
                    runeDepth: entry["runeDepth"].as_str().unwrap().parse::<i64>().unwrap(),
                    synthSupply: entry["synthSupply"]
                        .as_str()
                        .unwrap()
                        .parse::<i64>()
                        .unwrap(),
                    synthUnits: entry["synthUnits"]
                        .as_str()
                        .unwrap()
                        .parse::<i64>()
                        .unwrap(),
                    units: entry["units"].as_str().unwrap().parse::<i64>().unwrap(),
                    startTime: entry["startTime"].as_str().unwrap().parse::<i64>().unwrap(),
                    endTime: entry["endTime"].as_str().unwrap().parse::<i64>().unwrap(),
                    id: None, // This will be auto-generated by PostgreSQL
                };
                // println!("{:?}", assetPriceHistory);
                // Insert into the database
                // sqlx::query!(
                //     r#"
                //     INSERT INTO Depth_Price_History (
                //         assetDepth, assetPrice, assetPriceUSD, liquidityUnits, luvi,
                //         membersCount, runeDepth, synthSupply, synthUnits, units, startTime, endTime
                //     )
                //     VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
                //     "#,
                //     assetPriceHistory.assetDepth,
                //     assetPriceHistory.assetPrice,
                //     assetPriceHistory.assetPriceUSD,
                //     assetPriceHistory.liquidityUnits,
                //     assetPriceHistory.luvi,
                //     assetPriceHistory.membersCount,
                //     assetPriceHistory.runeDepth,
                //     assetPriceHistory.synthSupply,
                //     assetPriceHistory.synthUnits,
                //     assetPriceHistory.units,
                //     assetPriceHistory.startTime,
                //     assetPriceHistory.endTime
                // )
                // .execute(pool)
                // .await?;
                count += 1;
            }

            // Get the `end_time` of the last entry (the 400th entry)
            let last_entry = intervals.last().unwrap();
            let last_end_time = last_entry["endTime"]
                .as_str()
                .unwrap()
                .parse::<i64>()
                .unwrap();

            // If the `end_time` of the last entry is greater than or equal to current time, we are done
            if last_end_time >= end_time {
                break;
            }

            // Otherwise, update `from_time` to the `end_time` of the last entry
            from_time = last_end_time;
        } else {
            break; // No more data, exit loop
        }
    }
    println!("{:?}", count);
    Ok(())
}
